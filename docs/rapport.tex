\documentclass[12pt]{article}

\setlength{\parskip}{1.1em}
\setlength{\parindent}{0em}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[swedish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{times}
\usepackage{hyperref}
\usepackage{titlesec}
\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsubsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}

\title{Fundamentals of Artificial Intelligence (57205HT16): Assignment 1 -
Follow the path}
\author{
    Marc Coquand \\ 
    id14mcd \\
    mcoquand@gmail.com \and
		Linus Lagerhjelm \\
		id14llm \\
		id14llm@cs.umu.se \and \\
		Supervisor: Thomas Johansson\\
		Alexander Sutherland \\
		Thomas Hellstr√∂m
}
\date{\today}

\renewcommand{\baselinestretch}{1.0}
\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Introduction}


\section{Problem description}

The challenge is to make a \textit{mobile remote robot} drive around a given
\textit{path}, avoiding obstacles in the way and reach the goal. 

A mobile remote robot is described in the world by it's \textit{pose}. A pose is
defined as: $(x, y, z, \phi, \theta, \omega)$ where $(x,y,z)$ is the robots
position and $(\phi, \theta, \omega)$ is the robots roll, pith, yaw respectively
and denoted as Euler angles and are implemented as quaternions.

A path is defined as an ordered list of positions (I.e. from the robots starting
position to the end goal that is to be reached).

To control the robot we implement a \textit{high level controller}, 
\textit{low level controller} and a \textit{laser}. The reason for the separation is to have one class
where we take care of all the high level interaction with the world, i.e. path planing and one low
level controller that maps the plan to robot instructions.

The high level controller has the task of calculating the point in the path that
we want to travel to, defined as the GP. 

The low level controller calculates the math and logistics of moving the mobile
remote robot from its current position to a given point. It also makes sure
that the mobile robot will not collide with any obstacles on the way. It finds the
path to take from the robots current position to a given point by regulating the
robots angular speed (defined as $\omega$) and linear speed (defined as $v$).
The way it is calculated is described in the implementation of the Pure
Pursuit algorithm, described below.

The low level controller also works with the laser to check if there are any
obstacles to avoid. If it finds that there is an object in the way the
robot will slow down and continue turning so that it does not collide with the
object when driving forward. Lastly when the point is reached the low level
controller will make sure that the mobile robot slows down.  

The laser is a part of the mobile remote robot that checks, in a 270 degrees angle,
the distance to the nearest obstacle. In the implementation it will also check
if the robot is within a $0.4$ distance from any obstacle so that the low level
controller can deal with it.

In the simulation we have the world's coordinate system (denoted as
\textit{WCS}) given and can get the robot's pose in the WCS. 

\subsection{Pure Pursuit algorithm description}

To calculate the way to drive we utilize an algorithm called Pure Pursuit. The
idea of Pure pursuit is that we define two points, LOC and GP. LOC is the
current position of the robot in the WCS. GP is a calculated position in path
that we want to reach, also in the WCS. 

The way to calculate GP is by selecting a point within the path that is
just outside of a given look-a-head distance. The look-a-head distance is a
given parameter that can be modified in the program. A look-a-head
distance that is too high will result in difficulties for the robot to stay on the path.
If the look-a-head distance is too low, the robot will become too slow. It thus needs
to be tweaked by trial-and-error, in our program we recommend setting the look-a-head
distance to $0.5$.

Once GP and WCS has been set the algorithm constructs a circle that passes
through both points where the mobile robot's orientation is tangent to the
circle. The circle is defined by it's midpoint and radius $r$. The way it's done is
as follows:

Define $\vec{L} = (LOC, GP) \implies r = \frac{L_{y}^2}{2y}$. The curvature we
define as $\gamma = \frac{1}{r}$ and the angular speed that the robot will
take to reach GP will then be $\omega = v\gamma$. The linear speed will 
be $v$ which is defined by the program's input arguments. The intuition behind
this is demonstrated in figure~\ref{purepursuit}.





\bibliographystyle{abbrv}
\bibliography{rapport}


\end{document}
