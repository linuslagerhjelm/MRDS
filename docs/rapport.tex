\documentclass[12pt]{article}

\setlength{\parskip}{1.1em}
\setlength{\parindent}{0em}
\usepackage{pdfpages}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[swedish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{cite}
\usepackage{times}
\usepackage{hyperref}
\usepackage{titlesec}
\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsubsection{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}

\title{Fundamentals of Artificial Intelligence (57205HT16): Assignment 1 -
Follow the path}
\author{
    Marc Coquand \\ 
    id14mcd \\
    mcoquand@gmail.com \and
		Linus Lagerhjelm \\
		id14llm \\
		id14llm@cs.umu.se \and \\
		Supervisor: Thomas Johansson\\
		Alexander Sutherland \\
		Thomas Hellstr√∂m
}
\date{\today}

\renewcommand{\baselinestretch}{1.0}
\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Introduction}


\section{Problem description}

The challenge is to make a \textit{mobile remote robot} drive around a given
\textit{path}, avoiding obstacles in the way and reach the goal. 

A mobile remote robot is described in the world by it's \textit{pose}. A pose is
defined as: $(x, y, z, \phi, \theta, \omega)$ where $(x,y,z)$ is the robots
position and $(\phi, \theta, \omega)$ is the robots roll, pith, yaw respectively
and denoted as Euler angles and are implemented as quaternions.

A path is defined as a list of positions in the order that they're supposed to
be followed (I.e. the robots starting position to the end goal that is to be
reached).

To control the robot we implement a \textit{high level controller}, 
\textit{low level controller} and a \textit{laser}. The reason for the division is to have one class
where we take car of all the high level interaction with the world and one low
level interaction in the world. 

The high level controller has the task of calculating the point in the path that
we want to travel to, defined as the GP. 

The low level controller calculates the math and logistics of moving the mobile
remote robot from it's current position to a given point. It also makes sure
that the mobile robot will collide with any obstacles on the way. It finds the
path to take from the robots current position to a given point by regulating the
robots angular speed (defined as $\omega$) and linear speed (defined as $v$).
The way it cal is calculated is described in the implementation of the Pure
pursuit algorithm, described below.

The low level controller also works with the laser to check if there's any
obstacles to take care of. If it finds that there's an object in the way the
robot will slow down and continue turning so that it does not collide with the
object when driving forward. Lastly when the point is reached the low level
controller will make sure that the mobile robot slows down.  

The laser is a part of the mobile remote robot that checks in a 271 degree angle
the distance to the nearest obstacle. In the implementation it will also check
if the robot is within a $0.4$ distance from any obstacle so that the low level
controller can deal with it.

In the simulation we have the world's coordinate system (denoted as
\textit{WCS}) given and can get the robot's pose in the WCS. 

\subsection{Pure Pursuit algorithm description}

To calculate the way to drive we utilize an algorithm called Pure Pursuit. The
idea of Pure pursuit is that we define two points, LOC and GP. LOC is the
current position of the robot in the WCS. GP is a calculated position in path
that we want to reach, also in the WCS. 

The way to calculate GP is by selecting a point within the path list that is
just outside of a given look-a-head distance. The look-a-head distance is a
given parameter that can be modified in the program. If you select a look-a-head
distance that is too high the robot might have difficulty following the path and
crashing into a wall. If you select too low of a look-a-head distance the robot
might become too slow. It thus needs to be tweaked by trial-and-error, in our
program we recommend setting the look-a-head distance to $0.5$.

Once GP and WCS has been set the algorithm constructs a circle that passes
through both points where the mobile robot's orientation is tangent to the
circle. The circle is defined by it's midpoint and radius $r$. The way it's done is
as follows:

Define $\vec{L} = (LOC, GP) \implies r = \frac{L_{y}^2}{2y}$. The curvature we
define as $\gamma = \frac{1}{r}$ and the angular speed that the robot will
take to reach GP will then be $\omega = v\gamma$. The linear speed will 
be $v$ which is defined by the program's input arguments. The intuition behind
this is demonstrated in figure~\ref{purepursuit}.





\bibliographystyle{abbrv}
\bibliography{rapport}


\end{document}
